<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Management - Enterprise Mode (Control)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* CSS Styling */
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f7f6; }
        header { background-color: #007bff; color: white; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; }
        header h1 { margin: 0; font-size: 1.5em; }
        .mode-switch { background-color: #28a745; color: white; border: none; padding: 8px 15px; cursor: pointer; border-radius: 4px; transition: background-color 0.3s; }
        .mode-switch:hover { background-color: #218838; }
        .search-container { padding: 15px 20px; display: flex; gap: 10px; background-color: white; border-bottom: 1px solid #ddd; }
        #search-input { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 4px; }
        #map-container { border-bottom: 2px solid #ddd; }
        #map { height: 50vh; width: 100%; }
        /* Custom InfoWindow for Signal Timer */
        .signal-info-content { font-weight: bold; padding: 5px; font-size: 1.1em; }
        .signal-info-content .status-row { display: flex; justify-content: space-between; padding: 2px 0; font-size: 0.95em; }
        .red-light { color: #dc3545; }
        .green-light { color: #28a745; }
        .yellow-light { color: #ffc107; }
        /* Dashboard Styling */
        #control-dashboard { padding: 20px; background-color: #fff; margin-top: 10px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); display: none; }
        #control-dashboard h2 { color: #007bff; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .dashboard-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-top: 15px; }
        .chart-area { border: 1px solid #ccc; padding: 15px; border-radius: 4px; }
        .control-panel { padding: 15px; background-color: #f8f9fa; border-radius: 4px; }
        .mode-status { font-size: 1.2em; font-weight: bold; padding: 8px; border-radius: 4px; margin-bottom: 10px; }
        .auto-mode { background-color: #ffc107; color: #333; }
        .manual-mode { background-color: #dc3545; color: white; }
        .manual-controls button { width: 45%; margin: 5px 2%; padding: 10px 0; border: none; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; transition: opacity 0.3s; }
        .manual-controls button:nth-child(1) { background-color: #dc3545; } /* North */
        .manual-controls button:nth-child(2) { background-color: #ffc107; } /* East */
        .manual-controls button:nth-child(3) { background-color: #17a2b8; } /* West */
        .manual-controls button:nth-child(4) { background-color: #007bff; } /* South */
        #reset-btn { background-color: #6c757d; width: 94%; margin: 10px 3%; }
    </style>
</head>
<body>

    <header>
        <h1>‚öôÔ∏è Enterprise Mode: Signal Control Dashboard</h1>
        <button class="mode-switch" onclick="switchMode('enterprise')">Switch to User Mode</button>
    </header>

    <div class="search-container">
        <input type="text" id="search-input" placeholder="Search a location or intersection...">
        <button id="search-button" onclick="handleSearch()">Search</button>
        <button id="my-location-button" onclick="findMyLocation()">My Location üìç</button>
    </div>

    <div id="map-container">
        <div id="map"></div>
    </div>

    <div id="control-dashboard">
        <h2 id="dashboard-title">Select a Signal on the Map to View its Control Panel</h2>
        
        <div class="dashboard-grid">
            <div class="chart-area">
                <h3>Traffic Density (Vehicles / 5 min)</h3>
                <canvas id="density-chart"></canvas>
            </div>

            <div class="control-panel">
                <h3>Signal Control</h3>
                <div id="mode-indicator" class="mode-status auto-mode">Automatic Mode</div>
                
                <h4>Automatic Predictor Status:</h4>
                <p id="predictor-status">Awaiting data...</p>

                <hr>

                <h4>Manual Control Override: Set Green Light</h4>
                <div class="manual-controls">
                    <button onclick="setManualSignal('N')">NORTH</button>
                    <button onclick="setManualSignal('E')">EAST</button>
                    <button onclick="setManualSignal('W')">WEST</button>
                    <button onclick="setManualSignal('S')">SOUTH</button>
                </div>
                <button id="reset-btn" onclick="resetAutomatic()">Reset to Automatic</button>
            </div>
        </div>
    </div>

    <script>
        const API_KEY = 'AIzaSyD6kaZpN3w7eqo3V_EV0Ut_7la75UYhBts'; 
        const LOCAL_STORAGE_KEY = 'trafficSignalsData';
        let map;
        let trafficLayer;
        let infoWindow;
        let densityChart;
        let currentSignalId = null; 

        // State tracking
        let isManualMode = {}; 
        const directionLabels = ['N', 'E', 'W', 'S'];
        const directionMap = { 'N': 'North', 'E': 'East', 'W': 'West', 'S': 'South' };

        // --- Core Data Definitions (Will be populated from Local Storage) ---
        let mockSignals = []; 
        
        // --- Core Local Storage Functions ---

        // Load data from Local Storage 
        function loadDataFromStorage() {
            const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (storedData) {
                mockSignals = JSON.parse(storedData).map(s => ({ ...s, marker: null }));
                
                mockSignals.forEach(signal => {
                    isManualMode[signal.id] = localStorage.getItem(`isManual-${signal.id}`) === 'true';
                });
                return true;
            }
            return false;
        }

        // Save only the dynamic parts back to Local Storage (Control changes only)
        function saveDataToStorage() {
            const serializableSignals = mockSignals.map(s => {
                const { marker, ...rest } = s;
                return rest;
            });
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(serializableSignals));
        }

        // Utility function
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // --- Function to dynamically update density data for the chart ---
        function updateMockDensityData(signal) {
            const density = signal.density;
            let densityChanged = false;
            
            // Introduce minor fluctuations (+/- 10 vehicles) to simulate real-time traffic changes
            directionLabels.forEach(dir => {
                let currentValue = density[dir];
                let newValue = Math.max(20, Math.min(250, currentValue + getRandomInt(-10, 10)));
                if (newValue !== currentValue) {
                    density[dir] = newValue;
                    densityChanged = true;
                }
            });

            if (densityChanged && currentSignalId) {
                runAutomaticPredictor(signal);
                renderChart(signal);
            }
        }

        // =================================================================
        // 1. Map Initialization
        // =================================================================
        function initMap() {
            if (!loadDataFromStorage()) {
                alert("Error: User Mode (user.html) must be loaded first to initialize the traffic data. Please load user.html first.");
                mockSignals = [{ id: "I0", name: "LOAD FAILED - Refresh user.html first", lat: 18.5204, lng: 73.8567, marker: null, state: { N: { color: "red", timer: 10 }, S: { color: "red", timer: 10 }, E: { color: "red", timer: 10 }, W: { color: "red", timer: 10 } }, density: { N: 0, S: 0, E: 0, W: 0 } }];
            }
            
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 18.5204, lng: 73.8567 },
                zoom: 13,
                mapTypeControl: false,
            });

            trafficLayer = new google.maps.TrafficLayer();
            trafficLayer.setMap(map);
            infoWindow = new google.maps.InfoWindow();
            
            addSignalOverlays();
            setInterval(updateSignalTimers, 1000);
            
            // 1. Auto-predictor runs every 10s
            setInterval(() => {
                mockSignals.forEach(signal => runAutomaticPredictor(signal));
            }, 10000); 

            // 2. Chart data updates every 20 seconds (as requested)
            setInterval(() => {
                if (currentSignalId) {
                    const signal = mockSignals.find(s => s.id === currentSignalId);
                    if (signal) {
                        updateMockDensityData(signal);
                    }
                }
            }, 20000); 
        }

        // =================================================================
        // Signal Overlay and Timer Logic (Rereads data from storage)
        // =================================================================
        function addSignalOverlays() {
            mockSignals.forEach(signal => {
                const marker = new google.maps.Marker({
                    position: { lat: signal.lat, lng: signal.lng },
                    map: map,
                    title: signal.name,
                    icon: {
                        url: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30"><circle cx="15" cy="15" r="14" fill="%23FFFFFF" stroke="%23000000" stroke-width="2"/><text x="15" y="20" font-family="Arial" font-size="16" fill="%23000000" text-anchor="middle">üö¶</text></svg>',
                        scaledSize: new google.maps.Size(30, 30),
                        anchor: new google.maps.Point(15, 30)
                    }
                });
                signal.marker = marker;
                marker.addListener('click', () => {
                    infoWindow.setContent(getSignalInfoContent(signal));
                    infoWindow.open(map, marker);
                    openControlDashboard(signal.id); 
                });
            });
        }
        
        function getSignalInfoContent(signal) {
            let content = `<div class="signal-info-content"><b>${signal.name} Status</b><hr style="margin: 5px 0;">`;
            if (isManualMode[signal.id]) {
                content += `<p style="color:red; margin: 0 0 5px;">MANUAL OVERRIDE ACTIVE</p>`;
            }
            directionLabels.forEach(dir => {
                const status = signal.state[dir];
                let colorClass = status.color + '-light';
                content += `
                    <div class="status-row">
                        <span style="width: 25%;"><b>${dir}</b>:</span> 
                        <span class="${colorClass}" style="width: 40%; text-align: left; text-transform: uppercase;">${status.color}</span>
                        <span class="${colorClass}" id="timer-${signal.id}-${dir}" style="width: 35%; text-align: right;">${status.timer}s</span>
                    </div>
                `;
            });
            content += `</div>`;
            return content;
        }

        function updateSignalTimers() {
            // REREAD data from storage every second to get updates from user.html (timer/rotation) OR manual override (this page)
            loadDataFromStorage(); 
            
            mockSignals.forEach(signal => {
                let isInfoWindowOpen = false;

                directionLabels.forEach(dir => {
                    let status = signal.state[dir];
                    
                    const timerEl = document.getElementById(`timer-${signal.id}-${dir}`);
                    if (timerEl) {
                        isInfoWindowOpen = true;
                        const colorClass = status.color + '-light';
                        timerEl.textContent = `${status.timer}s`;
                        timerEl.className = colorClass;
                    }
                });

                if (isInfoWindowOpen && infoWindow.getContent().includes(`timer-${signal.id}`)) {
                    infoWindow.setContent(getSignalInfoContent(signal));
                    infoWindow.open(map, signal.marker);
                }
                
                if (signal.id === currentSignalId) {
                    updateDashboard(signal);
                }
            });
        }

        // =================================================================
        // ENTERPRISE DASHBOARD LOGIC (Writes to Local Storage)
        // =================================================================

        function openControlDashboard(signalId) {
            currentSignalId = signalId;
            const signal = mockSignals.find(s => s.id === signalId);
            document.getElementById('dashboard-title').textContent = `${signal.name} Control Panel (${signalId})`;
            document.getElementById('control-dashboard').style.display = 'block';

            renderChart(signal);
            updateDashboard(signal);
        }

        function renderChart(signal) {
            const ctx = document.getElementById(`density-chart`).getContext('2d');
            const densityData = signal.density;
            const dataValues = Object.values(densityData);
            const backgroundColors = dataValues.map(v => v > 150 ? 'rgba(255, 99, 132, 0.7)' : 'rgba(75, 192, 192, 0.7)');

            if (densityChart) { 
                densityChart.data.datasets[0].data = dataValues;
                densityChart.data.datasets[0].backgroundColor = backgroundColors;
                densityChart.update();
            } else {
                densityChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['North', 'East', 'West', 'South'],
                        datasets: [{
                            label: 'Vehicle Count / 5 min',
                            data: dataValues,
                            backgroundColor: backgroundColors,
                            borderWidth: 1
                        }]
                    },
                    options: { responsive: true, scales: { y: { beginAtZero: true } }, plugins: { legend: { display: false } } }
                });
            }
        }

        function updateDashboard(signal) {
            const modeEl = document.getElementById('mode-indicator');
            const statusEl = document.getElementById('predictor-status');

            if (isManualMode[signal.id]) {
                modeEl.textContent = "Manual Mode";
                modeEl.className = "mode-status manual-mode";
                const greenDir = directionLabels.find(dir => signal.state[dir].color === 'green');
                statusEl.textContent = `Manual Override: ${directionMap[greenDir]} is set to GREEN.`;
            } else {
                modeEl.textContent = "Automatic Mode";
                modeEl.className = "mode-status auto-mode";
                runAutomaticPredictor(signal);
            }
        }
        
        function runAutomaticPredictor(signal) {
            if (isManualMode[signal.id]) return;

            const density = signal.density;
            let maxDensity = -1;
            let priorityDir = '';
            for (const [dir, count] of Object.entries(density)) {
                if (count > maxDensity) { maxDensity = count; priorityDir = dir; }
            }
            
            const isNSAxis = (priorityDir === 'N' || priorityDir === 'S');
            const priorityAxis = isNSAxis ? ['N', 'S'] : ['E', 'W'];
            const crossingAxis = isNSAxis ? ['E', 'W'] : ['N', 'S'];

            const statusEl = document.getElementById('predictor-status');
            const currentGreenDir = directionLabels.find(dir => signal.state[dir].color === 'green');
            const currentGreenAxis = (currentGreenDir === 'N' || currentGreenDir === 'S') ? ['N', 'S'] : ['E', 'W'];

            // Check if the priority axis (heaviest traffic) is currently RED
            if (signal.state[priorityAxis[0]].color === 'red') {
                // PRIORITY SWITCH TRIGGERED: Update local mockSignals and save
                priorityAxis.forEach(dir => { signal.state[dir].color = 'green'; signal.state[dir].timer = 25; });
                crossingAxis.forEach(dir => { signal.state[dir].color = 'red'; signal.state[dir].timer = 35; });

                saveDataToStorage(); // Save predictor decision
                 if (statusEl) { statusEl.textContent = `Auto-Prediction: SWITCHED to ${priorityAxis.join('/')} (Density: ${maxDensity}).`; statusEl.style.color = 'red'; }
            } else {
                 if (statusEl) { statusEl.textContent = `Auto-Prediction: ${currentGreenAxis.join('/')} FLOWING. Next priority: ${priorityAxis.join('/')} (Density: ${maxDensity}).`; statusEl.style.color = 'green'; }
            }
        }

        /**
         * Sets the manual override and saves the state to Local Storage.
         */
        function setManualSignal(direction) {
            const signal = mockSignals.find(s => s.id === currentSignalId);
            if (!signal) return;

            // 1. Set Manual Mode Flags
            isManualMode[signal.id] = true;
            localStorage.setItem(`isManual-${signal.id}`, 'true'); 

            // 2. Set the Signal State (The key change!)
            directionLabels.forEach(dir => {
                // Set chosen direction to GREEN, others to RED
                signal.state[dir].color = (dir === direction) ? 'green' : 'red';
                signal.state[dir].timer = 60; // Set a long manual timer
            });

            // 3. Save the NEW STATE and MANUAL FLAG to Local Storage
            saveDataToStorage(); 
            updateDashboard(signal);
        }

        /**
         * Resets to Automatic and saves the resulting auto state to Local Storage.
         */
        function resetAutomatic() {
            const signal = mockSignals.find(s => s.id === currentSignalId);
            if (!signal) return;
            
            // 1. Reset Manual Mode Flags
            isManualMode[signal.id] = false;
            localStorage.setItem(`isManual-${signal.id}`, 'false'); // Persist reset status
            
            // 2. Run predictor to establish the new auto-state and save it
            runAutomaticPredictor(signal); // This function runs the logic AND saves the state
            updateDashboard(signal);
        }

        // =================================================================
        // Search and Geolocation & Navigation (Shared)
        // =================================================================
        function findMyLocation() {
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const pos = { lat: position.coords.latitude, lng: position.coords.longitude };
                        map.setCenter(pos);
                        map.setZoom(15);
                        new google.maps.Marker({ position: pos, map: map, title: "Your Location" });
                    },
                    (error) => { console.error("Geolocation Error:", error.message); alert("Could not retrieve your location. Error: " + error.message); }
                );
            } else { alert("Geolocation is not supported by your browser."); }
        }

        function handleSearch() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) return;
            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ 'address': query }, (results, status) => {
                if (status === 'OK') {
                    map.setCenter(results[0].geometry.location);
                    map.setZoom(15);
                    new google.maps.Marker({ map: map, position: results[0].geometry.location });
                } else { alert('Geocode was not successful for the following reason: ' + status); }
            });
        }
        
        function switchMode(currentPage) {
            if (currentPage === 'user') {
                window.location.href = 'enterprise.html';
            } else if (currentPage === 'enterprise') {
                window.location.href = 'user.html';
            }
        }
        
        // Expose functions globally for HTML buttons
        window.setManualSignal = setManualSignal;
        window.resetAutomatic = resetAutomatic;
        window.findMyLocation = findMyLocation;
        window.handleSearch = handleSearch;
        
        function loadGoogleMapsScript() {
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&callback=initMap`;
            script.async = true;
            document.head.appendChild(script);
        }
        document.addEventListener('DOMContentLoaded', loadGoogleMapsScript);
    </script>
</body>
</html>