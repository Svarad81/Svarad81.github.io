<!doctype html>
<html lang="en">
<head>
  <meta charset="utf--8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Drowsiness Detector (Fixed)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;padding:12px;max-width:900px;margin:0 auto; background-color: #f0f2f5;}
    .row{display:flex;flex-wrap: wrap; gap:8px;align-items:center;margin:8px 0}
    video{width:100%;max-height:480px;border-radius:8px;transform:scaleX(-1);display:block; background-color: #000;}
    canvas{position:absolute;left:0;top:0; width: 100%; height: 100%;}
    .box{background:#fff;padding:12px;border-radius:10px;box-shadow:0 2px 4px rgba(0,0,0,.1);margin-bottom:12px}
    pre{background:#1e1e1e;color:#d4d4d4;padding:10px;border-radius:8px;height:180px;overflow:auto; font-family: 'Courier New', Courier, monospace;}
    #alert{display:none;background:#ffdddd;border:2px solid #ff5a5a;padding:10px;border-radius:8px;text-align:center;font-weight:700; color: #d8000c;}
    button { background-color: #4a90e2; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; transition: background-color: 0.3s; }
    button:disabled { background-color: #cccccc; cursor: not-allowed; }
    button:hover:not(:disabled) { background-color: #357abd; }
    input { padding: 10px; border-radius: 5px; border: 1px solid #ccc; }
    #video-container { position: relative; width: 100%; max-width: 640px; margin: auto; }
  </style>
</head>
<body>
  <h1>Drowsiness Detection</h1>

  <div class="box">
    <div class="row">
      <input id="room" placeholder="Room ID (e.g. test1)" />
      <button id="roleDriver">Driver (Camera)</button>
      <button id="roleCar">Car (Listener)</button>
      <button id="start" disabled>Start</button>
      <button id="stop" disabled>Stop</button>
    </div>
    <small>Note: This app requires HTTPS or localhost for camera access.</small>
  </div>

  <div id="driverBox" class="box" style="display:none">
    <h3>Driver (Camera)</h3>
    <div id="video-container">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay"></canvas>
    </div>
    <p id="status">Status: Initializing...</p>
  </div>

  <div id="carBox" class="box" style="display:none">
    <h3>Car (Listener)</h3>
    <div id="alert">🚨 Drowsiness Alert!</div>
    <button id="ack" style="display:none">Acknowledge</button>
  </div>

  <div class="box">
    <h3>Logs & Network</h3>
    <pre id="log"></pre>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
  <!-- NEW MODEL: Using BlazeFace for robust face detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
  
  <script>
  // ===== CONFIG: JSONBin values =====
  const JSONBIN_MASTER_KEY = "$2a$10$mdQ2p6Aczav/B7UASEbddOtXtV7ZukGzb1IoUPBX8Rg4kwcC7Z1Sq";
  const JSONBIN_BIN_ID    = "68cefa56d0ea881f408475ab";
  const JSONBIN_URL       = `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`;
  // ===================================

  // --- Parameters (Tunable) ---
  const ABSENT_FRAMES_THRESHOLD = 25; // Trigger alert after 25 frames with no face
  const POLL_MS = 3000;

  // --- DOM Elements ---
  const $room = document.getElementById('room');
  const $roleDriver = document.getElementById('roleDriver');
  const $roleCar = document.getElementById('roleCar');
  const $start = document.getElementById('start');
  const $stop = document.getElementById('stop');
  const $driverBox = document.getElementById('driverBox');
  const $carBox = document.getElementById('carBox');
  const $video = document.getElementById('video');
  const $overlay = document.getElementById('overlay');
  const $status = document.getElementById('status');
  const $log = document.getElementById('log');
  const $alert = document.getElementById('alert');
  const $ack = document.getElementById('ack');

  // --- State Variables ---
  let role = null;
  let running = false;
  let model = null;
  let absentCount = 0; // Counts consecutive frames where no face is detected
  let lastAlertCount = 0;
  let pollIntervalId = null;
  let alertTimer = null;
  let audioCtx = null; // To hold the audio context for alerts
  let alertInterval = null; // To control the repeating alert sound/vibration

  function log(msg){
    const t = new Date().toLocaleTimeString();
    const logMsg = `[${t}] ${msg}`;
    $log.textContent = logMsg + '\n' + $log.textContent;
    console.log(logMsg);
  }

  // --- Event Listeners ---
  $roleDriver.onclick = () => { role='driver'; $driverBox.style.display='block'; $carBox.style.display='none'; $start.disabled=false; log("Role selected: DRIVER"); };
  
  $roleCar.onclick = () => {
    role='car'; 
    $carBox.style.display='block'; 
    $driverBox.style.display='none'; 
    $start.disabled=false; 
    log("Role selected: CAR");
    // **MODIFIED**: Create and unlock AudioContext on user gesture (role selection)
    if (!audioCtx) {
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
        log('Audio permissions granted. Ready for alerts.');
      } catch(e) {
        log('Failed to initialize audio: ' + e.message);
      }
    }
  };

  $start.onclick = async () => {
    if(!role){ alert('Please pick a role first.'); return; }
    if(!$room.value){ alert('Please enter a room ID.'); return; }
    running = true; $start.disabled=true; $stop.disabled=false;
    if(role==='driver'){ await startDriver($room.value); }
    else startCar($room.value);
  };
  $stop.onclick = () => { stopAll(); };
  $ack.onclick = () => { stopAlert(); log('Alert acknowledged by user.'); };
  
  // --- DRIVER (Camera + Detection) ----------
  async function startDriver(room){
    log('Requesting camera permission...');
    try{
      let stream = null;
      try {
        stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'}});
      } catch(e){
        log('Front camera failed, trying default camera: '+e.message);
        stream = await navigator.mediaDevices.getUserMedia({video:true});
      }
      log('Camera permission granted.');
      
      $video.srcObject = stream;
      await new Promise(resolve => $video.onloadedmetadata = resolve);

      $overlay.width = $video.videoWidth;
      $overlay.height = $video.videoHeight;
      log(`Camera started with resolution ${$video.videoWidth}x${$video.videoHeight}`);

      await tf.setBackend('webgl');
      log('TensorFlow.js backend set to WebGL.');

      log('Loading BlazeFace model...');
      model = await blazeface.load();
      log('BlazeFace model loaded successfully.');
      
      detectLoop(room);
    }catch(err){
      log('ERROR starting driver mode: ' + err);
      console.error(err);
    }
  }

  async function detectLoop(room){
    if(!running) return;
    if(!$video || $video.readyState < 2){
      requestAnimationFrame(()=>detectLoop(room));
      return;
    }

    const faces = await model.estimateFaces($video, false);
    
    const ctx = $overlay.getContext('2d');
    ctx.clearRect(0,0,$overlay.width,$overlay.height);

    if(faces.length > 0){
      // Face detected
      absentCount = 0;
      $status.textContent = `Status: Face Detected | Frames Absent: ${absentCount}`;
      
      // Draw bounding box for visual feedback
      const face = faces[0];
      const start = face.topLeft;
      const end = face.bottomRight;
      const size = [end[0] - start[0], end[1] - start[1]];

      ctx.strokeStyle = 'aqua';
      ctx.lineWidth = 2;
      ctx.strokeRect(start[0], start[1], size[0], size[1]);

    } else {
      // No face detected
      absentCount++;
      $status.textContent = `Status: NO FACE DETECTED | Frames Absent: ${absentCount}`;

      if(absentCount >= ABSENT_FRAMES_THRESHOLD){
        log('DROWSINESS/ABSENCE DETECTED: Sending alert.');
        saveAlertToDB(room, {timestamp: new Date().toISOString(), type: 'absence_drowsiness'});
        absentCount = 0; // Reset after sending alert
      }
    }

    requestAnimationFrame(()=>detectLoop(room));
  }

  // ---------- JSONBin Communication ----------
  async function safeFetch(url, options) {
    const res = await fetch(url, options);
    log(`JSONBin ${options.method || 'GET'} Status: ${res.status} ${res.statusText}`);
    if (!res.ok) throw new Error(`HTTP error! ${res.status} ${res.statusText}`);
    return await res.json();
  }

  async function getBin() {
    return await safeFetch(JSONBIN_URL, { headers: { 'X-Master-Key': JSONBIN_MASTER_KEY } });
  }

  async function updateBin(recordObj) {
    return await safeFetch(JSONBIN_URL, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', 'X-Master-Key': JSONBIN_MASTER_KEY },
      body: JSON.stringify(recordObj)
    });
  }

  async function saveAlertToDB(room, alertObj){
    try{
      const bin = await getBin();
      const record = bin.record || {};
      record.sessions = record.sessions || {};
      record.sessions[room] = record.sessions[room] || { frames:[], alerts:[], sos:[] };
      record.sessions[room].alerts.push(alertObj);
      await updateBin(record);
      log('Alert saved to DB successfully.');
    }catch(e){
      let errorMsg = e.message;
      if (errorMsg.includes('Failed to fetch')) {
          errorMsg += ' (Check internet/CORS/ad-blocker)';
      }
      log('Alert save failed: '+ errorMsg);
    }
  }

  // ---------- CAR (Listener) Role ----------
  function startCar(room){
    log('Car mode started. Polling for alerts...');
    if (!audioCtx) {
        log('WARNING: Audio not initialized. Alerts might be silent. Try re-selecting the CAR role.');
    }
    pollIntervalId = setInterval(()=>pollAlerts(room), POLL_MS);
  }

  async function pollAlerts(room){
    try{
      const bin = await getBin();
      const alerts = (bin.record?.sessions?.[room]?.alerts) || [];
      if(alerts.length > lastAlertCount){
        lastAlertCount = alerts.length;
        showAlert();
      }
    }catch(e){ 
      let errorMsg = e.message;
      if (errorMsg.includes('Failed to fetch')) {
          errorMsg += ' (Please check internet connection, CORS policy, or disable ad-blockers)';
      }
      log('Car poll failed: ' + errorMsg);
    }
  }

  function playUrgentBeep() {
    if(audioCtx){
      try {
        const playBeep = (freq, startTime, duration) => {
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = 'triangle';
          o.frequency.value = freq;
          o.connect(g);
          g.connect(audioCtx.destination);
          g.gain.setValueAtTime(0, startTime);
          g.gain.linearRampToValueAtTime(0.5, startTime + 0.05);
          g.gain.linearRampToValueAtTime(0, startTime + duration);
          o.start(startTime);
          o.stop(startTime + duration);
        };
        const now = audioCtx.currentTime;
        playBeep(1200, now, 0.1);
        playBeep(1200, now + 0.15, 0.1);
        playBeep(1200, now + 0.3, 0.1);
      } catch(e) {
        log('Beep failed: ' + e.message);
      }
    }
  }

  function showAlert(){
    log('ALERT received by car!');
    $alert.style.display='block';
    $ack.style.display='inline-block';
    
    const alertAction = () => {
      playUrgentBeep();
      if(navigator.vibrate) navigator.vibrate([400, 100, 400]);
    };
    
    // Clear any existing alert interval to avoid overlap
    if (alertInterval) clearInterval(alertInterval);
    
    // Start a new, faster alert interval
    alertAction(); // Trigger immediately
    alertInterval = setInterval(alertAction, 1000); // Repeat every second

    if(alertTimer) clearTimeout(alertTimer);
    alertTimer = setTimeout(()=>escalateSOS(), 7000); // Faster SOS escalation
  }

  function stopAlert(){
    $alert.style.display='none';
    $ack.style.display='none';
    if(alertTimer) clearTimeout(alertTimer);
    if(alertInterval) clearInterval(alertInterval); // Stop the repeating alert
  }

  async function escalateSOS(){
    const room = $room.value;
    log('Escalating to SOS (unacknowledged alert)');
    const sos = { timestamp:new Date().toISOString(), msg:'SOS (unacknowledged)' };
    try{
      const bin = await getBin();
      const record = bin.record || {};
      record.sessions = record.sessions || {};
      record.sessions[room] = record.sessions[room] || { frames:[], alerts:[], sos:[] };
      record.sessions[room].sos.push(sos);
      await updateBin(record);
      stopAlert();
      $alert.innerHTML = "🚨 **SOS LOGGED!** 🚨<br>Contact emergency services manually.";
      $alert.style.display = 'block';
      $alert.style.background = '#990000';
      $alert.style.color = 'white';
    }catch(e){ log('SOS save failed: '+ e.message); }
  }

  // ---------- General Control ----------
  function stopAll(){
    running = false;
    if($video.srcObject){ $video.srcObject.getTracks().forEach(t=>t.stop()); }
    if(pollIntervalId) clearInterval(pollIntervalId);
    stopAlert();
    if (audioCtx && audioCtx.state !== 'closed') {
      audioCtx.close();
      audioCtx = null;
    }
    $start.disabled=false; $stop.disabled=true;
    log('Stopped all operations.');
  }

  // --- Initial Check on Load ---
  (function(){
    if(!location.protocol.startsWith('https' ) && !['localhost', '127.0.0.1'].includes(location.hostname)){
      log('⚠️ WARNING: Camera access requires a secure context (HTTPS) or localhost. The app may not work.');
    } else {
      log('App ready.');
    }
  })();
  </script>
</body>
</html>
